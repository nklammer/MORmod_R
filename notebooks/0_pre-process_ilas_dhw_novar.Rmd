---
title: "Step 1: Preprocess data for analysis"
author: "Noah Klammer"
date: "10/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Clear global and report

```{r}
rm(list = ls())
gc()
ptm <- proc.time() # start timer
```


# Import

## Timeseries from "zemf_ilas_dhw_novar"

```{r import, message=FALSE, warning=FALSE}
## Import
library(readr)
# specify automatic assignment of double variable type to columns with .default
output <- read_csv("~/MORmod_R/input/zemf_ilas_dhw_novar/output.dview", 
    skip = 1, col_types = list(.default = col_double()))
# DView format has a 1x1 header followed by 3xN header
#   take out the headers in "tidy" fashion
df <- output %>% slice(-(1:3))
```

```{r remove vars not studied}
## Remove variables not studied
vars_not_studied <- c(
  "Site|Pumps:Electricity",
  "Site|WaterSystems:Electricity",
  "Site|Cooling:Electricity",
  "Site|DistrictCooling:Facility",
  "Site|Electricity:Facility",
  "Site|ExteriorLights:Electricity",
  "Site|Fans:Electricity",
  "Site|HeatRecovery:Electricity",
  "Site|Heating:Electricity",
  "Site|DistrictHeating:Facility",
  "Site|InteriorEquipment:Electricity",
  "Site|InteriorLights:Electricity"
)

# remove in "tidy" fashion
df <- df %>% select(-contains(vars_not_studied))

```



```{r infer time sampling, include=FALSE}
## Infer time sampling

# uncomment below to see the parsed var types for cols
#   readr::spec(df)

data_freq <- "null"
rows <- nrow(df) 
if (rows==4*24*(365||366)) {
  data_freq <- "15 minutes"
} else if (rows==24*(365||366)) {
  data_freq <- "hourly"
} else if (rows==12) {
  data_freq <- "monthly"
} else {}
```

There are ``r ncol(df)`` column variables in this file with names like ``r names(df)[3]``, ``r names(df)[6]``, and ``r names(df)[50]``.

The data_frequency of this .eso file's timestep is ``r data_freq``.

## Add in hour, day, month

```{r Create columns "hour", "day", "month"}
# create a date/time columns
#   month, day, hour

# add `hour_index` column in "tidy" fashion
df <- df %>% add_column(hour_index = 1:nrow(df), .before = 1)

# add `hour` column in "tidy" fashion
df <- df %>% add_column(hour = rep(0:23,length.out = nrow(df)), .before = 1)

add_months <- function(df) {
  if (nrow(df)==24*365) { # if leap year
    days_in_month <- 24*c(31,28,31,30,31,30,31,31,30,31,30,31)
    }
  else if (nrow(df)==24*366) { # if not leap year
    days_in_month <- 24*c(31,29,31,30,31,30,31,31,30,31,30,31)
  }
  # create atomic array of days and months info
  month_num <- 1:12
  array_months <- cbind(days_in_month, month_num)

  # returns the month number
  #   custom function that repeats the the month number
  #   by the number of days in that month
  make_month_num <- function(x) {rep(x["month_num"], times = x["days_in_month"])}
  month_nums <- unlist(apply(array_months, 1, make_month_num))
  
  # add as `month` column in "tidy" fashion
  df %>% add_column(month = month_nums, .before = 1) 
  }

add_days_of_month <- function(df) {
  if (nrow(df)==24*365) { # if leap year
    days_in_month <- c(31,28,31,30,31,30,31,31,30,31,30,31)
  }
  else if (nrow(df)==24*366) { # if not leap year
    days_in_month <- c(31,29,31,30,31,30,31,31,30,31,30,31)
  }
  # create atomic array of days and months info
  month_num <- 1:12
  array_months <- cbind(days_in_month, month_num)

  # returns the day of the month
  #   length(day_of_month) == 24*(365||366)
  returns_day_of_month <- unlist(lapply(days_in_month, function(x) {seq(1:x)}))
  day_nums <- rep(returns_day_of_month, each = 24)
  
  # add as `day` column in "tidy" fashion
  df %>% add_column(day = day_nums, .before = 1) 
}

df <- add_days_of_month(df)
df <- add_months(df)
```

## Drop either heating or cooling ideal load

Drop either the heating ideal load or the cooling ideal load based on the climate and context of the model.

```{r}
# change comment below to switch
dropped_var <- "Heating"
#dropped_var <- "Cooling"
df <- df %>% select(-contains(dropped_var))
```


### Zone names for columns

```{r}
# Drop and then add back later "" column
#   because I am not smart enough to 
#   do it in "dplyr" fashion 
time_date_col_names <- c("month","day","hour","hour_index")
time_date_data <- df %>% select(all_of(time_date_col_names))
df <- df %>% select(-all_of(time_date_col_names))

# REGEX expression
# any char at least once preceded by "Energy|" AND
#   followed by " " OR " - " then any char 
#   at least 0 followed by " IDEAL LOADS"
regex_str <- "(?<=Energy\\|).+(?=\\sIDEAL\\sLOADS)"
# extract the zone names based on above REGEX
zone_names <- str_extract(colnames(df), regex_str)
colnames(df) <- zone_names # zone names become new col names

```

# Inspect Zones and select only residential zones of interest

Dwelling units, stairwells, and corridors above the first floor are all considered residential zones.

```{r}
# can I do this in "tidy" fashion
df <- df %>%
  select(contains("STAIRWELL") | contains("CORRIDOR") | contains("BDRM")) %>%
  select(sort(current_vars()))

# add time/date columns back in
df <- bind_cols(time_date_data, df)

# auto checker
#   bool check that time/date cols are present
time_date_present <- length(time_date_col_names) == df %>% select(all_of(time_date_col_names)) %>% ncol(.)

#   bool check that no extra cols are present
no_extra_col <- 0 == df %>% select(-c(all_of(time_date_col_names), contains("STAIRWELL") | contains("CORRIDOR") | contains("BDRM"))) %>% ncol(.)

```

The auto checker revealed that it is ``r time_date_present`` that time and date columns are present in the dataframe after this step. The auto checker revealed that it is ``r no_extra_col`` that no extra columns are present.

### Rowname labels

Named rows are helpful labels for a dataframe that undergoes unsupervised clustering.

```{r Add rownames, warning=FALSE}
## Add rownames to dataframe
#   could also do this in Excel

# constructs "human" date/time vector from existing columns
row_date_time_labels <- paste0(month.abb[df$month]," ", df$day, ", ", df$hour, ":00")
# inserts rownames, adds physical unit name
rownames(df) <- paste(row_date_time_labels,"Ideal Energy Use [J]") # Add in variable name
```


### Data QA/QC: remove observations with NA

```{r}
# remove NA observations
# remove minute col if subhourly data DNE
if (is.null(df$minute)) { # do nothing, check if exists
  } else if (var(df$minute)==0) { # take out minute with zero variance
  df <- select(df,-minute)} else { # do nothing
  }

if (anyNA(df)) { # then
  df <- df %>% na.omit()
}
# remove the automatic row numbers
# rownames(df) <- NULL
```


### Data QA/QC: zero variance

```{r include=FALSE}

sel_days_df <- df 

# visdat::vis_cor(sel_days_df)
#=> "the standard deviation is zero"

# let's find which cols have zero variance
zv <- which(apply(sel_days_df, 2, var) == 0)

zero_var_zones <- str_subset(colnames(sel_days_df)[zv],"")

# get zones that str match with "cooling"
c <- zero_var_zones
# get zones that str match with "heating"
# h <- grep("*\\Deating", zero_var_zones, value = TRUE)

# extracts zone name logic
# c <- str_extract(c,"(?<=SYSTEM\\s).*(?=\\:)")
# h <- str_extract(h,"(?<=SYSTEM\\s).*(?=\\:)")

# are there any zones with neither heating nor cooling?
# intersect(c,h)
#=> unconditioned zones

# remove the unc zones from
# `zero_var_zone_names` string list
zero_var_zone_names <- zero_var_zones
```

The longer we work with this data set, the more clear it is that many zones have zero variance. We see that ``r length(zero_var_zones)`` out of ``r length(sel_days_df)`` zones have zero variance for this temporal range.

We find that there are ``r length(c)`` zones with no cooling load and `0` zones with no heating load. We assert that `r length(zero_var_zones)` have neither cooling nor heating load. These zones are unconditioned spaces.

Naturally, for a correctly defined building energy model, few if any hours of a certain zone will have both heating and cooling. For possible future regression purposes, I will treat heating load as negative cooling load.


### Save as .Rda R data file

```{r}
ilas_dhw_novar <- df
save(ilas_dhw_novar, file = "~/MORmod_R/files/ilas_dhw_novar.Rda")
proc.time() - ptm # end timer
```


<br><br><br>