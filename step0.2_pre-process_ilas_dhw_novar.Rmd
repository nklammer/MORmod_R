---
title: "Step 1: Preprocess data for analysis"
author: "Noah Klammer"
date: "6/27/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Clear global and report

```{r}
rm(list = ls())
gc()
```


# Import

## ESO timeseries from "zemf_ilas_dhw_novar_eso"

```{r import, message=FALSE, warning=FALSE}
library(readr)
ilas_df <- read_csv("data_in/zemf_ilas_dhw_novar_eso.csv", 
    skip = 3)
colnames(ilas_df)[1] <- "Date/Time"
#View(ilas_df)


```


```{r infer time sampling, include=FALSE}
# readr::spec(ilas_df)
freq <- "null"
rows <- nrow(ilas_df) 
if (rows==8760*4) {
  freq <- "15 minutes"
} else if (rows==8760) {
  freq <- "hourly"
} else if (rows==12) {
  freq <- "monthly"
} else {freq <- "could not determine"}
```
There are ``r ncol(ilas_df)`` column variables in this file with names like ``r names(ilas_df)[3]``, ``r names(ilas_df)[6]``, and ``r names(ilas_df)[50]``.

The frequency of this .eso file's timestep is ``r freq``.

### Time names for rows

Named rows are helpful labels for a dataframe without 'being' data per se.

```{r warning=FALSE}
# probably just easier to do this in Excel
eighty760_labels <- str_replace(ilas_df$`Date/Time`,"/\\d{4}","") # take out year
rownames(ilas_df) <- eighty760_labels

rownames(ilas_df) <- paste(ilas_df$`Date/Time`,"Ideal Tot. Clg Load [J]") # Add in variable name
# rownames intact here
```

## Area to Zone mapping

Load in an external data set of rows with two attributes: zone name and floor area in m^2.

```{r message=FALSE, warning=FALSE}
area_map <- read_csv("ZoneFloorArea-Map.csv")
# rownames intact here
```

Since the zone-area dataset and the Ideal Air Loads dataset may have different order, create a simple indexing function.

### Inspect Zones and select only residential zones of interest

Dwelling units, stairwells, and corridors above the first floor are all considered residential zones.

```{r}
res_list <- 
c(
grep("STAIRWELL_\\d", colnames(ilas_df), value = TRUE),
grep("CORRIDOR_\\d", colnames(ilas_df), value = TRUE),  
grep("BDRM", colnames(ilas_df), value = TRUE)
)

sorted_list <- stringr::str_sort(res_list, numeric = TRUE)

ilas_df <- ilas_df[sorted_list]
```


### Normalize Loads by Floor Area

```{r warning=FALSE}
# drop Date/Time col
time_col <- ilas_df[,1]
rownames(time_col) <- rownames(ilas_df) # rownames lost here
ilas_df <- ilas_df[,-1] # rownames here

idx_s <- function(str) {
  which(str==area_map$`Zone List`)
  }
# change regex
slist <- str_extract(colnames(ilas_df),".+(?=\\sILAS|\\sI)" ) # any char followed by ' ILAS' or ' I'
colnames(ilas_df) <- slist
idx2 <- sapply(slist,idx_s)
vec <- area_map$`Space Area [m2]`[idx2]

# apply normalization vector across columns
ilas_df <- sweep(ilas_df, 2, vec, FUN = "/") 

# change colnames to reflect metric
# **[J]** => [J/m^2]
rownames(ilas_df) <- str_replace(rownames(ilas_df),"(?<=\\[)J{1}","J/m^2")
rownames(ilas_df) <- paste(eighty760_labels, "Ideal Tot. Clg Load [J/m^2]")
```


### Add Date/Time back in

```{r warning=FALSE}
`Date/Time` <- time_col
ilas_df <- cbind(`Date/Time`,ilas_df)
```

### Create columns for categorical month, day, hour, minute

```{r warning=FALSE}
# separate the date and time into cols month, day, hour, minute
# make sure to have two digits for all days and months
ilas_df <- ilas_df %>%
  mutate(month = as.integer(substr(`Date/Time`, start = 1, stop = 2)),
         day = as.integer(substr(`Date/Time`, start = 4, stop = 5)),
         hour = as.integer(substr(`Date/Time`, start = 7, stop = 8)), # hour is not working
         `Date/Time` = as.integer(substr(`Date/Time`, start = 10, stop = 11))) %>%
  rename(minute = `Date/Time`)

sorted_list <- stringr::str_sort(colnames(ilas_df), numeric = TRUE)

ilas_df <- ilas_df[sorted_list]
# numeric month var to month string
# ilas_df <- transform(ilas_df, month = month.abb[month])

```


### Data QA/QC: remove observations with NA

```{r}
# remove NA observations
# remove minute col if subhourly data DNE
if (is.null(ilas_df$minute)) { # do nothing, check if exists
  } else if (var(ilas_df$minute)==0) { # take out minute with zero variance
  ilas_df <- select(ilas_df,-minute)} else { # do nothing
  }

if (anyNA(ilas_df)) { # then
  ilas_df <- ilas_df %>% na.omit()
}
# remove the automatic row numbers
# rownames(ilas_df) <- NULL
```


### Data QA/QC: zero variance

```{r include=FALSE}

sel_days_ilas_df <- ilas_df 

# visdat::vis_cor(sel_days_ilas_df)
#=> "the standard deviation is zero"

# let's find which cols have zero variance
zv <- which(apply(sel_days_ilas_df, 2, var) == 0)

z_var_zones <- str_subset(colnames(sel_days_ilas_df)[zv],"")

# get zones that str match with "cooling"
c <- z_var_zones
# get zones that str match with "heating"
# h <- grep("*\\Deating", z_var_zones, value = TRUE)

# extracts zone name logic
# c <- str_extract(c,"(?<=SYSTEM\\s).*(?=\\:)")
# h <- str_extract(h,"(?<=SYSTEM\\s).*(?=\\:)")

# are there any zones with neither heating nor cooling?
# intersect(c,h)
#=> unconditioned zones

# remove the unc zones from
# `zero_var_zone_names` string list
z_var_zone_names <- z_var_zones
```

The longer we work with this data set, the more clear it is that many zones have zero variance. We see that ``r length(z_var_zones)`` out of ``r length(sel_days_ilas_df)`` zones have zero variance for this temporal range.

We find that there are ``r length(c)`` zones with no cooling load and `0` zones with no heating load. We assert that `r length(z_var_zones)` have neither cooling nor heating load. These zones are unconditioned spaces.

Naturally, for a correctly defined building energy model, few if any hours of a certain zone will have both heating and cooling. For possible future regression purposes, I will treat heating load as negative cooling load.


### Save as .Rda R data file

```{r}
ilas_dhw_novar <- ilas_df
save(ilas_dhw_novar,file = "ilas_dhw_novar.Rda")
```


<br><br><br>